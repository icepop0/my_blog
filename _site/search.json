[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Présentation",
    "section": "",
    "text": "OlympicsWeather est un package conçu pour R, offrant la possibilité de récupérer et afficher les informations météorologiques liées à une adresse spécifique ou à des coordonnées GPS.\nCe package intègre trois fonctions clés : get_forecast, qui récupère les prévisions météo et les présente sous forme de tibble ; visualiser_forecast_d, qui fournit une visualisation des données météorologiques sur une base quotidienne ; et visualiser_forecast_h, qui permet d’afficher les prévisions météo heure par heure."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Bienvenue sur le blog olympicsWeather !",
    "section": "",
    "text": "Cliquer pour plus d’informations.\nOlympicsWeather est un package conçu pour R, offrant la possibilité de récupérer et afficher les informations météorologiques liées à une adresse spécifique ou à des coordonnées GPS.\nCe package intègre trois fonctions clés : get_forecast, qui récupère les prévisions météo et les présente sous forme de tibble ; visualiser_forecast_d, qui fournit une visualisation des données météorologiques sur une base quotidienne ; et visualiser_forecast_h, qui permet d’afficher les prévisions météo heure par heure.\nÀ vos marques, prêt, codez !\nPour installer le package, vous entrerez la commande suivante :\nremotes::install_github(\"icepop0/olympicsWeather\")\n! Notez que pour lancer cette commande, vous devez avoir lancé le package remotes.\nSi ce n’est pas le cas, exécutez cette commande :\ninstall.packages(\"remotes\")\nlibrary(remotes)\n\n\nQuelles sont les prévisions météo à 7 jours pour le Stade de France ?\n\nlibrary(olympicsWeather)\nvisualiser_forecast_d(\"stade de france\")\n\nPassing 1 address to the Nominatim single address geocoder\n\n\nQuery completed in: 1 seconds\n\n\n\n\n\nTahiti ?\n\nvisualiser_forecast_d(\"Tahiti\")\n\nPassing 1 address to the Nominatim single address geocoder\n\n\nQuery completed in: 1 seconds\n\n\n\n\n\nEt pour les coordonnées GPS 43.276703, 5.334791 ?\n\nvisualiser_forecast_d(43.276703, 5.334791)"
  },
  {
    "objectID": "posts/welcome/index.html#bienvenu-welcome-bienvenido",
    "href": "posts/welcome/index.html#bienvenu-welcome-bienvenido",
    "title": "Bienvenue sur le blog olympicsWeather !",
    "section": "",
    "text": "Cliquer pour plus d’informations.\nOlympicsWeather est un package conçu pour R, offrant la possibilité de récupérer et afficher les informations météorologiques liées à une adresse spécifique ou à des coordonnées GPS.\nCe package intègre trois fonctions clés : get_forecast, qui récupère les prévisions météo et les présente sous forme de tibble ; visualiser_forecast_d, qui fournit une visualisation des données météorologiques sur une base quotidienne ; et visualiser_forecast_h, qui permet d’afficher les prévisions météo heure par heure.\nÀ vos marques, prêt, codez !"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "olympicsWeather",
    "section": "",
    "text": "Exercice1\n\n\n\n\n\n\n\n\n\n\n\n\nAngel Sineau\n\n\n\n\n\n\n  \n\n\n\n\nExercice2\n\n\n\n\n\n\n\n\n\n\n\n\nAngel SINEAU\n\n\n\n\n\n\n  \n\n\n\n\nExercice3\n\n\n\n\n\n\n\n\n\n\n\n\nAngel SINEAU\n\n\n\n\n\n\n  \n\n\n\n\nBienvenue sur le blog olympicsWeather !\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMar 9, 2024\n\n\nAngel SINEAU\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/welcome/index.html#librairie-olympicsweather",
    "href": "posts/welcome/index.html#librairie-olympicsweather",
    "title": "Bienvenue sur le blog olympicsWeather !",
    "section": "",
    "text": "Cliquer pour plus d’informations.\nOlympicsWeather est un package conçu pour R, offrant la possibilité de récupérer et afficher les informations météorologiques liées à une adresse spécifique ou à des coordonnées GPS.\nCe package intègre trois fonctions clés : get_forecast, qui récupère les prévisions météo et les présente sous forme de tibble ; visualiser_forecast_d, qui fournit une visualisation des données météorologiques sur une base quotidienne ; et visualiser_forecast_h, qui permet d’afficher les prévisions météo heure par heure.\nÀ vos marques, prêt, codez !\nPour installer le package, vous entrerez la commande suivante :\nremotes::install_github(\"icepop0/olympicsWeather\")\n! Notez que pour lancer cette commande, vous devez avoir lancé le package remotes.\nSi ce n’est pas le cas, exécutez cette commande :\ninstall.packages(\"remotes\")\nlibrary(remotes)\n\n\nQuelles sont les prévisions météo à 7 jours pour le Stade de France ?\n\nlibrary(olympicsWeather)\nvisualiser_forecast_d(\"stade de france\")\n\nPassing 1 address to the Nominatim single address geocoder\n\n\nQuery completed in: 1 seconds\n\n\n\n\n\nTahiti ?\n\nvisualiser_forecast_d(\"Tahiti\")\n\nPassing 1 address to the Nominatim single address geocoder\n\n\nQuery completed in: 1 seconds\n\n\n\n\n\nEt pour les coordonnées GPS 43.276703, 5.334791 ?\n\nvisualiser_forecast_d(43.276703, 5.334791)"
  },
  {
    "objectID": "posts/Exercice - Semaine 1/Exercice1.html#m1-ecap---202324",
    "href": "posts/Exercice - Semaine 1/Exercice1.html#m1-ecap---202324",
    "title": "Exercice1",
    "section": "M1 ECAP - 2023/24",
    "text": "M1 ECAP - 2023/24\nPour cet exercice, nous allons télécharger un jeu de données issu de https://data.gouv.fr sur les infrastructures olympiques des JO 2024 à Paris. Le jeu de données est disponible ici.\nL’objectif de cet exercice est d’utiliser uniquement des fonctions de R base.\n\n1. Créez un script .R intitulé exercice.R.\n\n\n2. Lisez le fichier téléchargé. Le résultat sera affecté à l’objet de nom data_ex.\n\n\nLe jeux de données contient 4 colonnes.\n\n\nQuels sont les noms et la nature des colonnes ?\n\n\nCombien de lignes contient la data.frame ?\n\ndata_ex = read.csv2(\"paris-2024-sites-olympiques-et-paralympiques-franciliens.csv\") \n\nsummary(data_ex) \n\n  geo_point             nom            sites_olympiques_paralympiques\n Length:31          Length:31          Length:31                     \n Class :character   Class :character   Class :character              \n Mode  :character   Mode  :character   Mode  :character              \n    sports         \n Length:31         \n Class :character  \n Mode  :character  \n\ncolnames(data_ex)\n\n[1] \"geo_point\"                      \"nom\"                           \n[3] \"sites_olympiques_paralympiques\" \"sports\"                        \n\nstr(data_ex) \n\n'data.frame':   31 obs. of  4 variables:\n $ geo_point                     : chr  \"48.841319, 2.253076\" \"48.924388, 2.359871\" \"48.751095, 2.0759\" \"48.788046, 2.034987\" ...\n $ nom                           : chr  \"Parc des Princes\" \"Stade de France\" \"Golf national\" \"Vélodrome National de Saint-Quentin-en-Yvelines\" ...\n $ sites_olympiques_paralympiques: chr  \"Site olympique\" \"Site olympique,Site paralympique\" \"Site olympique\" \"Site olympique,Site paralympique\" ...\n $ sports                        : chr  \"Football\" \"Athlétisme,Para athlétisme,Rugby\" \"Golf\" \"Cyclisme sur piste,Para cyclisme sur piste\" ...\n\ndim(data_ex)\n\n[1] 31  4\n\n\n\nLes noms des colonnes dans ma base data_ex sont geo_point, nom, sites_olympiques_paralympiques, et sports.\nToutes les colonnes sont de type character, ce qui signifie qu’elles contiennent des données textuelles.\nMa base data_ex contient 31 lignes, indiquant que j’ai des informations sur 31 sites olympiques ou paralympiques différents.\n\n\n\n3 & 4. Combien y a t’il de sites olympiques, paralympiques ?\n\ntable(data_ex$sites_olympiques_paralympiques)\n\n\n                                                   Site olympique \n                               2                               10 \nSite olympique,Site paralympique                Site paralympique \n                              16                                3 \n\n\n10 sites sont seulement olympiques, 3 sont seulement paralympiques, et 16 sont mixtes. Il y a également 2 valeurs manquantes, dans la colonne sites_olympiques_paralympiques.\n\n\n\n\n\n5. Quels sont les sites qui accueillent plusieurs disciplines sportives ?\n\nsites_multiples_sports &lt;- data_ex[grep(\",\", data_ex$sports), ]\n\nprint(sites_multiples_sports$nom) \n\n [1] \"Stade de France\"                                \n [2] \"Vélodrome National de Saint-Quentin-en-Yvelines\"\n [3] \"Stade Roland Garros\"                            \n [4] \"Arena Paris Sud 4 (Porte de Versailles)\"        \n [5] \"Pont d'Iéna\"                                    \n [6] \"Arena Bercy\"                                    \n [7] \"Arena Paris nord\"                               \n [8] \"Arena Paris Sud 6 (Porte de Versailles)\"        \n [9] \"Stade de la Concorde\"                           \n[10] \"Arena Champs de Mars\"                           \n[11] \"La Défense Arena\"                               \n[12] \"Stade nautique\"                                 \n[13] \"Arena Paris Sud 1 (Porte de Versailles)\"        \n[14] \"Stade Tour Eiffel\"                              \n[15] \"Arena La Chapelle\"                              \n[16] \"Centre aquatique\"                               \n[17] \"Château de Versailles\"                          \n[18] \"Grand Palais\"                                   \n[19] \"Invalides\"                                      \n\ntable(sites_multiples_sports$nom) \n\n\n                                    Arena Bercy \n                                              1 \n                           Arena Champs de Mars \n                                              1 \n                              Arena La Chapelle \n                                              1 \n                               Arena Paris nord \n                                              1 \n        Arena Paris Sud 1 (Porte de Versailles) \n                                              1 \n        Arena Paris Sud 4 (Porte de Versailles) \n                                              1 \n        Arena Paris Sud 6 (Porte de Versailles) \n                                              1 \n                               Centre aquatique \n                                              1 \n                          Château de Versailles \n                                              1 \n                                   Grand Palais \n                                              1 \n                                      Invalides \n                                              1 \n                               La Défense Arena \n                                              1 \n                                    Pont d'Iéna \n                                              1 \n                                Stade de France \n                                              1 \n                           Stade de la Concorde \n                                              1 \n                                 Stade nautique \n                                              1 \n                            Stade Roland Garros \n                                              1 \n                              Stade Tour Eiffel \n                                              1 \nVélodrome National de Saint-Quentin-en-Yvelines \n                                              1 \n\ndim(sites_multiples_sports)\n\n[1] 19  4\n\n\n19 sites accueillent plusieurs disciplines sportives.\n\n\n6. Quels sont les disciplines para-olympiques accueillies dans ces sites franciliens ?\n\nsites_paralympiques_mixtes &lt;- data_ex[grepl(\"Site paralympique\", data_ex$sites_olympiques_paralympiques), ]\n\ndisciplines_paralympiques &lt;- unique(sites_paralympiques_mixtes$sports)\nprint(disciplines_paralympiques)\n\n [1] \"Athlétisme,Para athlétisme,Rugby\"                                \n [2] \"Cyclisme sur piste,Para cyclisme sur piste\"                      \n [3] \"Tennis,Tennis fauteuil,Boxe\"                                     \n [4] \"Para cyclisme sur route\"                                         \n [5] \"Tennis de table,Para tennis de table\"                            \n [6] \"Basketball,Basket fauteuil,Gymnastique artistique,trampoline\"    \n [7] \"Boxe,Escrime,Pentathlon moderne,Volley-ball assis\"               \n [8] \"Haltérophilie,Handball,Goalball\"                                 \n [9] \"Judo,Para judo,Lutte,Rugby fauteuil\"                             \n[10] \"Natation,Para natation,Water-polo\"                               \n[11] \"Canoë,Para canoë,Aviron,Para aviron\"                             \n[12] \"Volleyball,Boccia\"                                               \n[13] \"Volleyball de plage,Cécifoot\"                                    \n[14] \"Badminton,Para Badminton,Gymnastique rythmique,Para powerlifting\"\n[15] \"Goalball\"                                                        \n[16] \"Sports équestres,Para équitation,Pentathlon moderne\"             \n[17] \"Para athlétisme\"                                                 \n[18] \"Escrime,Escrime fauteuil,Taekwondo,Para taekwondo\"               \n[19] \"Tir à l'arc,Para tir à l'arc,Athlétisme,Cyclisme sur route\"      \n\n\nLes disciplines sont les suivantes :\n\nPara athlétisme\nCyclisme sur piste, sur route\nTennis de table\nJudo\nNatation\nAviron\nBadminton\nPowerlifting\nEquitation\nAthlétisme\nTaekwondo\nTir à l’arc\n\n\n\n\n7. Quel(s) site(s) accueille(nt) le plus de disciplines différentes ?\n\n# Séparation des disciplines sportives et comptage pour chaque site\n# La fonction strsplit va séparer les sports sur chaque site, qui sont séparés par des virgules\ndata_ex$sports_list &lt;- strsplit(data_ex$sports, \",\")\n\n# Calcul du nombre de sports pour chaque site\n# La fonction sapply va appliquer la fonction length à chaque liste de sports pour chaque site\ndata_ex$nombre_sports &lt;- sapply(data_ex$sports_list, length)\n\n# Identification du ou des site(s) qui accueillent le plus de disciplines différentes\n# La fonction which.max va trouver l'index du site ou des sites avec le nombre maximal de sports\nsites_max_sports &lt;- data_ex[which(data_ex$nombre_sports == max(data_ex$nombre_sports)), ]\n\n# Affichage des sites avec le nombre maximum de disciplines différentes\nprint(sites_max_sports$nom)\n\n[1] \"Arena Bercy\"          \"Arena Paris nord\"     \"Stade de la Concorde\"\n[4] \"Arena Champs de Mars\" \"Stade nautique\"       \"Arena La Chapelle\"   \n[7] \"Grand Palais\"         \"Invalides\"           \n\n\nLe résultat indique que les sites accueillant le plus grand nombre de disciplines différentes sont les suivants :\n\nArena Bercy\nArena Paris nord\nStade de la Concorde\nArena Champs de Mars\nStade nautique\nArena La Chapelle\nGrand Palais\nInvalides\n\n\n\n8. Quel discipline aura lieu sur le plus grand nombre de sites ? Quels sont ces sites ?\n\n# Séparation des disciplines sportives pour chaque site\ndata_ex$sports_list &lt;- strsplit(data_ex$sports, \",\")\n\n# Aplatir la liste des sports en un seul vecteur\nsports_flat &lt;- unlist(data_ex$sports_list)\n\n# Compter la fréquence de chaque sport\nsports_count &lt;- table(sports_flat)\n\n# Trouver le sport le plus fréquent\nmost_frequent_sport &lt;- names(which.max(sports_count))\n\n# Identifier les sites accueillant ce sport\nsites_most_frequent_sport &lt;- data_ex[names(data_ex)[which(sapply(data_ex$sports_list, function(x) most_frequent_sport %in% x))], \"nom\"]\n\n# Afficher le sport le plus fréquent et les sites correspondants\nprint(paste(\"La discipline la plus répandue est:\", most_frequent_sport))\n\n[1] \"La discipline la plus répandue est: Athlétisme\"\n\nprint(\"Les sites accueillant cette discipline sont :\")\n\n[1] \"Les sites accueillant cette discipline sont :\"\n\nprint(sites_most_frequent_sport)\n\n[1] NA NA NA NA\n\n# Filtrer les données pour la discipline d'Athlétisme\nsites_athletisme &lt;- data_ex[grepl(\"Athlétisme\", data_ex$sports), ]\n\n# Extraire les noms des sites accueillant l'Athlétisme\nnoms_sites_athletisme &lt;- unique(sites_athletisme$nom)\n\n# Affichage des noms des sites\nprint(\"Les sites accueillant l'athlétisme sont :\")\n\n[1] \"Les sites accueillant l'athlétisme sont :\"\n\nprint(noms_sites_athletisme)\n\n[1] \"Stade de France\"         \"Hôtel de ville de Paris\"\n[3] \"Pont d'Iéna\"             \"Invalides\"              \n\n\n\nLa discipline qui aura lieu sur le plus grand nombre de sites est l’athlétisme. Les lieux en question sont :\n\nStade de France\nHôtel de ville de Paris\nPont d’Iéna\nInvalides\n\n\n\n9. A vol d’oiseau, quels sont les sites les deux sites les plus proches ?\n\n# Charger la librairie geosphere pour le calcul de distance\nlibrary(geosphere)\n\nWarning: le package 'geosphere' a été compilé avec la version R 4.3.3\n\n# Extraire les coordonnées et les transformer en matrice numérique\ncoords &lt;- strsplit(as.character(data_ex$geo_point), \", \")\ncoords &lt;- do.call(rbind, lapply(coords, as.numeric))\n\n# Calculer les distances entre tous les couples de sites\ndistances &lt;- distm(coords, fun = distHaversine)\n\n# Trouver la paire de sites la plus proche\nmin_distance &lt;- which(distances == min(distances[upper.tri(distances)]), arr.ind = TRUE)\n\n# Afficher les noms des deux sites les plus proches\nprint(paste(\"Les deux sites les plus proches sont :\", data_ex$nom[min_distance[1,1]], \"et\", data_ex$nom[min_distance[1,2]]))\n\n[1] \"Les deux sites les plus proches sont : Stade BMX de Saint-Quentin-en-Yvelines et Vélodrome National de Saint-Quentin-en-Yvelines\"\n\n\nLes deux sites les plus proches sont : Stade BMX de Saint-Quentin-en-Yvelines et Vélodrome National de Saint-Quentin-en-Yvelines.\n\n\n10. Quels sont les deux sites les plus éloignés ?\n\n# Charger la librairie nécessaire pour le calcul de distance\nlibrary(geosphere)\n\n# Extraire les coordonnées et les convertir en numérique\ncoords &lt;- strsplit(as.character(data_ex$geo_point), \", \")\ncoords &lt;- lapply(coords, function(x) as.numeric(x))\ncoords &lt;- do.call(rbind, coords)\n\n# Calculer les distances entre tous les sites\ndistances &lt;- distm(coords, coords, fun = distHaversine)\n\n# Trouver les indices des deux sites les plus proches\nindices_proches &lt;- which(distances == min(distances[upper.tri(distances)]), arr.ind = TRUE)\n\n# Trouver les indices des deux sites les plus éloignés\nindices_eloignes &lt;- which(distances == max(distances), arr.ind = TRUE)\n\n# Afficher les noms des sites les plus proches\nprint(\"Les deux sites les plus proches sont :\")\n\n[1] \"Les deux sites les plus proches sont :\"\n\nprint(data_ex$nom[indices_proches])\n\n[1] \"Stade BMX de Saint-Quentin-en-Yvelines\"         \n[2] \"Vélodrome National de Saint-Quentin-en-Yvelines\"\n[3] \"Vélodrome National de Saint-Quentin-en-Yvelines\"\n[4] \"Stade BMX de Saint-Quentin-en-Yvelines\"         \n\n# Afficher les noms des sites les plus éloignés\nprint(\"Les deux sites les plus éloignés sont :\")\n\n[1] \"Les deux sites les plus éloignés sont :\"\n\nprint(data_ex$nom[indices_eloignes])\n\n[1] \"Colline d'Elancourt\" \"Stade nautique\"      \"Stade nautique\"     \n[4] \"Colline d'Elancourt\"\n\n\nLes deux sites les plus éloignés sont la Colline d’Elancourt et le Stade Nautique.\n\n\n11. Vous êtes un heureux millionaire et souhaitez investir dans un bien immobilier. Vous décidez d’acheter un appartement situé au barycentre de l’ensemble des sites olympiques.\n\n\nOù se situe cet appartement ?\n\n# Sélection des sites olympiques et mixtes\nsites_olympiques &lt;- data_ex[grepl(\"Site olympique\", data_ex$sites_olympiques_paralympiques), ]\n\n# Extraction des coordonnées géographiques\ncoords &lt;- strsplit(as.character(sites_olympiques$geo_point), \", \")\ncoords &lt;- lapply(coords, function(x) as.numeric(x))\ncoords &lt;- do.call(rbind, coords)\n\n# Calcul du barycentre\nbarycentre &lt;- colMeans(coords)\n\n# Affichage des coordonnées du barycentre\nprint(paste(\"Le barycentre des sites olympiques est situé aux coordonnées suivantes : Latitude =\", barycentre[1], \", Longitude =\", barycentre[2]))\n\n[1] \"Le barycentre des sites olympiques est situé aux coordonnées suivantes : Latitude = 48.8581648461538 , Longitude = 2.27905757692308\"\n\n\nD’après les résultats, le barycentre des sites olympiques est situé aux coordonnées suivantes : Latitude = 48.8581648461538, Longitude = 2.27905757692308 ce qui se situe à Paris, plus précisément au 17 Place du Trocadéro et du 11 Novembre."
  },
  {
    "objectID": "posts/Exercice - Semaine 2/Exercice2.html#m1-ecap---202324",
    "href": "posts/Exercice - Semaine 2/Exercice2.html#m1-ecap---202324",
    "title": "Exercice2",
    "section": "M1 ECAP - 2023/24",
    "text": "M1 ECAP - 2023/24\n\nlibrary(rvest)\n\nWarning: le package 'rvest' a été compilé avec la version R 4.3.3\n\nlibrary(purrr)\n\nWarning: le package 'purrr' a été compilé avec la version R 4.3.3\n\n\n\n1.Lancez la commande suivante :\n\nlist_tables &lt;- session(\"https://fr.wikipedia.org/wiki/Liste_des_m%C3%A9daill%C3%A9s_olympiques\") |&gt; html_elements(\".wikitable\") |&gt; html_table()\n\n\n\nQue s’est-il passé ? Que contient l’objet list_tables ?\nNous obtenons une liste de dataframes, chaque dataframe représentant un tableau différent extrait de la page Wikipedia.\n\n\n2. Nous allons tout d’abord nous intéresser à la première table. Créez un objet intitulé data_medailles_sport_ete contenant le premier élément de list_tables. La table n’est pas bien formattée. Supprimez la première colonne, les noms de colonnes et la première ligne. Renommez les colonnes en c(“Discipline”, “Annees”, “Editions”, “Epreuves_2020”, “Or”, “Argent”, “Bronze”, “Total”, “Athletes_medailles”, “Athletes_or”). Les colonnes Editions, Epreuves_2020, Or, Argent, Bronze, Total seront converties en colonnes d’entiers.\n\n# Création de l'objet data_medailles_sport_ete\ndata_medailles_sport_ete &lt;- list_tables[[1]]\n\n# Suppression de la première colonne\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[, -1]\n\n# Suppression des noms de colonnes actuels et de la première ligne\ncolnames(data_medailles_sport_ete) &lt;- NULL\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[-1, ]\n\n# Renommage des colonnes\ncolnames(data_medailles_sport_ete) &lt;- c(\"Discipline\", \"Annees\", \"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\", \"Athletes_medailles\", \"Athletes_or\")\n\n# Conversion des colonnes Editions, Epreuves_2020, Or, Argent, Bronze, Total en entiers\ncols_to_convert &lt;- c(\"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\")\ndata_medailles_sport_ete[cols_to_convert] &lt;- lapply(data_medailles_sport_ete[cols_to_convert], as.integer)\n\n\n\n3.Quelles sont les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques ?\n\n# Création de data_medailles_sport_ete avec le premier élément de list_tables\ndata_medailles_sport_ete &lt;- list_tables[[1]]\n\n# Suppression de la première colonne, des noms de colonnes et de la première ligne\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[-1, -1]\n\n# Renommage des colonnes\ncolnames(data_medailles_sport_ete) &lt;- c(\"Discipline\", \"Annees\", \"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\", \"Athletes_medailles\", \"Athletes_or\")\n\n# Conversion des colonnes Editions, Epreuves_2020, Or, Argent, Bronze, Total en entiers\ncols_to_convert &lt;- c(\"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\")\ndata_medailles_sport_ete[cols_to_convert] &lt;- lapply(data_medailles_sport_ete[cols_to_convert], as.integer)\n\n# Trouver les 3 disciplines avec le plus de médailles\ntop_disciplines &lt;- head(data_medailles_sport_ete[order(-data_medailles_sport_ete$Total), \"Discipline\"], 3)\n\n# Afficher les résultats\nprint(\"Les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques sont :\")\n\n[1] \"Les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques sont :\"\n\nprint(top_disciplines)\n\n# A tibble: 3 × 1\n  Discipline              \n  &lt;chr&gt;                   \n1 Athlétisme              \n2 Natation(hommes, femmes)\n3 Lutte                   \n\n\nAinsi, nous observons que l’Athlétisme, la Natation, et la Lutte sont les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques.\n\n\n4.Quelles sont les disciplines avec le moins d’épreuves en 2020 ?\n\n# Trier les données par le nombre d'épreuves en 2020\ndata_triée &lt;- data_medailles_sport_ete[order(data_medailles_sport_ete$Epreuves_2020), ]\n\n# Sélectionner les disciplines avec le moins d'épreuves\ndisciplines_moins_epreuves &lt;- head(data_triée)\n\n# Afficher les résultats\nprint(disciplines_moins_epreuves$Discipline)\n\n[1] \"Football\"              \"Golf\"                  \"Handball\"             \n[4] \"Hockey sur gazon\"      \"Natation synchronisée\" \"Pentathlon moderne\"   \n\n\nLes disciplines avec le moins d’épreuves en 2020 sont :\n\nLe Football\nLe Golf\nLe Handball\nLe Hockey sur gazon\nLa Natation sychronisée\nLe pentathlon moderne.\n\n\n\n5. La colonne Editions nous renseigne sur le nombre total d’apparence des disciplines aux JO d’été. Nous souhaitons vérifier ce calcul en implémentant notre propre fonction calcul_nb_editions_int. Dans un premier temps, la fonction calcul_nb_editions prendra en entrée un paramètre depuis, de type entier, qui représente depuis quelle année la discipline est au programme.\n\ncalcul_nb_editions_int &lt;- function(depuis) {\n    # Années des jeux olympiques d'été, avec les annulations de 1940 et 1944\n    jeux_olympiques_annees &lt;- seq(1896, 2020, by = 4)\n    jeux_olympiques_annees &lt;- jeux_olympiques_annees[!jeux_olympiques_annees %in% c(1940, 1944)]\n    \n    # Compter le nombre d'éditions depuis l'année spécifiée\n    nombre_editions &lt;- sum(jeux_olympiques_annees &gt;= depuis)\n    \n    return(nombre_editions)\n}\n\n\n\n6. Dans certains cas, les disciplines ont été au programme de façon discontinue. Proposez une nouvelle fonction calcul_nb_editions_str qui prendra cette fois-ci en entrée des chaînes de caractères. Par exemple, l’appel suivant: calcul_nb_editions_str(“1896, 1904, depuis 1920”) retournera la valeur 26.\n\ncalcul_nb_editions_str &lt;- function(chaine_annees) {\n    # Années des jeux olympiques d'été, avec les annulations de 1940 et 1944\n    jeux_olympiques_annees &lt;- seq(1896, 2020, by = 4)\n    jeux_olympiques_annees &lt;- jeux_olympiques_annees[!jeux_olympiques_annees %in% c(1940, 1944)]\n    \n    # Découper la chaîne de caractères en morceaux\n    annees_parts &lt;- strsplit(chaine_annees, \", \")[[1]]\n    \n    # Initialiser un vecteur pour stocker toutes les années mentionnées\n    toutes_annees &lt;- numeric(0)\n    \n    for (part in annees_parts) {\n        if (grepl(\"depuis\", part)) {\n            # Extraire l'année et ajouter toutes les années depuis cette année\n            depuis_annee &lt;- as.numeric(sub(\"depuis \", \"\", part))\n            toutes_annees &lt;- c(toutes_annees, jeux_olympiques_annees[jeux_olympiques_annees &gt;= depuis_annee])\n        } else {\n            # Ajouter l'année spécifique\n            toutes_annees &lt;- c(toutes_annees, as.numeric(part))\n        }\n    }\n    \n    # Compter les éditions uniques\n    nombre_editions &lt;- length(unique(toutes_annees))\n    \n    return(nombre_editions)\n}\n\n# Test de la fonction\ncalcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n\n[1] 26\n\n\n\n\n7. Définissez une fonction générique calcul_nb_editions et deux implémentations calcul_nb_editions.integer et ’calcul_nb_editions.character. Quels résultats donnent les appels : calcul_nb_editions(2000) calcul_nb_editions(“1904–1924, depuis 1948”) ?\n\ncalcul_nb_editions_str &lt;- function(chaine_annees) {\n    # Années des jeux olympiques d'été, avec les annulations de 1940 et 1944\n    jeux_olympiques_annees &lt;- seq(1896, 2020, by = 4)\n    jeux_olympiques_annees &lt;- jeux_olympiques_annees[!jeux_olympiques_annees %in% c(1940, 1944)]\n    \n    # Découper la chaîne de caractères en morceaux\n    annees_parts &lt;- strsplit(chaine_annees, \", \")[[1]]\n    \n    # Initialiser un vecteur pour stocker toutes les années mentionnées\n    toutes_annees &lt;- numeric(0)\n    \n    for (part in annees_parts) {\n        if (grepl(\"depuis\", part)) {\n            # Extraire l'année et ajouter toutes les années depuis cette année\n            depuis_annee &lt;- as.numeric(sub(\"depuis \", \"\", part))\n            toutes_annees &lt;- c(toutes_annees, jeux_olympiques_annees[jeux_olympiques_annees &gt;= depuis_annee])\n        } else {\n            # Ajouter l'année spécifique\n            toutes_annees &lt;- c(toutes_annees, as.numeric(part))\n        }\n    }\n    \n    # Compter les éditions uniques\n    nombre_editions &lt;- length(unique(toutes_annees))\n    \n    return(nombre_editions)\n}\n\n# Test de la fonction\ncalcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n\n[1] 26\n\n# Fonction générique\ncalcul_nb_editions &lt;- function(x) {\n    UseMethod(\"calcul_nb_editions\", x)\n}\n\n# Implémentation pour integer\ncalcul_nb_editions.integer &lt;- function(depuis) {\n    jeux_olympiques_annees &lt;- seq(1896, 2020, by = 4)\n    jeux_olympiques_annees &lt;- jeux_olympiques_annees[!jeux_olympiques_annees %in% c(1940, 1944)]\n    sum(jeux_olympiques_annees &gt;= depuis)\n}\n\n# Implémentation pour character\ncalcul_nb_editions.character &lt;- function(periodes) {\n    jeux_olympiques_annees &lt;- seq(1896, 2020, by = 4)\n    jeux_olympiques_annees &lt;- jeux_olympiques_annees[!jeux_olympiques_annees %in% c(1940, 1944)]\n    periodes &lt;- gsub(\"depuis \", \"\", periodes)\n    periodes &lt;- gsub(\"–\", \"-\", periodes)\n    periodes_separes &lt;- unlist(strsplit(periodes, \", \"))\n    total &lt;- 0\n    for (periode in periodes_separes) {\n        if (grepl(\"-\", periode)) {\n            annees &lt;- as.numeric(unlist(strsplit(periode, \"-\")))\n            total &lt;- total + sum(jeux_olympiques_annees &gt;= annees[1] & jeux_olympiques_annees &lt;= annees[2])\n        } else {\n            total &lt;- total + sum(jeux_olympiques_annees &gt;= as.numeric(periode))\n        }\n    }\n    return(total)\n}\n\n# Tests des fonctions\nprint(calcul_nb_editions(2000L))  \n\n[1] 6\n\n\nCes fonctions calculeront le nombre d’éditions des Jeux Olympiques d’été auxquelles une discipline a participé, soit depuis une année donnée (integer), soit pendant des périodes spécifiées (character).\nLes appels calcul_nb_editions(2000) et calcul_nb_editions(\"1904-1924, depuis 1948\") nous donnent respectivement le nombre d’éditions depuis l’année 2000 et pour les périodes 1904-1924 et depuis 1948, soit 6 éditions.\n\n\n8. En Athlétisme, le Finlandais Paavo Nurmi détient le record de médailles avec 12 médailles obtenues lors des JO d’hiver. Implémentez une fonction calcul_medailles_individuelles qui détermine le nombre de médaille maximal a été obtenu par un athlète lors d’olympiades. Note : s’il y a plusieurs athlètes à égalité, alors la cellule comporte plusieurs éléments, et une manipulation de la chaîne de caractères est nécessaire.\n\ncalcul_medailles_individuelles &lt;- function(info_medailles) {\n    # Séparer les athlètes s'il y en a plusieurs\n    athletes &lt;- unlist(strsplit(info_medailles, \",\"))\n    \n    # Extraire les nombres de médailles et convertir en entiers\n    nombre_medailles &lt;- sapply(athletes, function(athlete) {\n        if(grepl(\"\\\\d+\", athlete)) {\n            max(as.numeric(unlist(regmatches(athlete, gregexpr(\"\\\\d+\", athlete)))))\n        } else {\n            0\n        }\n    })\n    \n    # Déterminer le nombre maximal de médailles\n    max_medailles &lt;- max(nombre_medailles)\n    \n    return(max_medailles)\n}\n\nCette fonction permettra de déterminer le nombre maximal de médailles obtenues par un athlète, même dans des cellules où plusieurs athlètes sont mentionnés.\n\n\n9. Quel est le top 3 des athlètes ? Vous utiliserez la fonction lapply pour appliquer la fonction calcul_medailles_individuelles à chaque élément de la colonne Athletes_medailles.\n\ncalcul_medailles_individuelles &lt;- function(medailles) {\n    # Vérifier si l'entrée est NA\n    if (is.na(medailles)) {\n        return(NA)\n    }\n    \n    # Séparer les entrées pour chaque athlète\n    athletes &lt;- strsplit(medailles, \", \")[[1]]\n    \n    # Initialiser un vecteur pour stocker le nombre total de médailles par athlète\n    nombre_medailles_total &lt;- numeric(length(athletes))\n\n    # Boucle sur chaque athlète pour extraire le nombre total de médailles\n    for (i in seq_along(athletes)) {\n        # Extraire les nombres de médailles de l'athlète courant\n        medailles_athlete &lt;- unlist(strsplit(athletes[i], \" \"))\n\n        # Convertir les nombres en entiers et sommer\n        nombre_medailles_total[i] &lt;- sum(as.numeric(medailles_athlete[sapply(medailles_athlete, is.numeric)]))\n    }\n\n    # Retourner le nombre maximal de médailles\n    max(nombre_medailles_total, na.rm = TRUE)\n}\n\n# Appliquer la fonction à chaque élément de la colonne Athletes_medailles\ntop_medailles &lt;- lapply(data_medailles_sport_ete$Athletes_medailles, calcul_medailles_individuelles)\n\n# Déterminer le top 3 des athlètes\ntop_3 &lt;- sort(unlist(top_medailles), decreasing = TRUE)[1:3]\n\n# Afficher le top 3\nprint(top_3)\n\n[1] 0 0 0\n\n\n\n\n10. Quels sont les 3 nationalités les plus représentées, pour toutes les épreuves, au classement du nombre de médailles d’or individuelles reccueillies ? • Pour ce faire, vous implémenterez une fonction extraire_nationalite_athlete qui à partir d’une chaine de charactère extraira le nombre d’athlète et leur nationalité. Par exemple, la chaine de caractère “Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)” donnera en sortie c(“FIN” = 1, “USA” = 1). • Vous utilisez la fonction lapply pour appliquer la fonction à toute la colonne 2 • Vous agrégerez les résultats de manière à sommer toutes les lignes et à obtenir les 3 nations les plus représentées, et leur effectif.\n\n# Définition de la fonction\nextraire_nationalite_athlete &lt;- function(texte) {\n    # Extraire les codes de nationalité et les occurences d'athlètes\n    # Le code ici dépend de la structure exacte de vos données\n    # Par exemple, vous pouvez utiliser des expressions régulières pour extraire les informations nécessaires\n}\n\n# Application de la fonction à la colonne\nresultats &lt;- lapply(data_medailles_sport_ete$Athletes_medailles, extraire_nationalite_athlete)\n\n# Agrégation des résultats\nnationalites &lt;- table(unlist(resultats))\n\n# Tri et identification des trois premières nationalités\ntop3_nationalites &lt;- sort(nationalites, decreasing = TRUE)[1:3]\n\n\n\n11. Intéressez-vous désormais au deuxième tableau contenu dans list_tables, faisant référence aux JO d’hiver. Appliquez les fonctions calcul_medailles_individuelles et extraire_nationalite_athlete aux deux dernières colonnes, à la manière des questions 9 et 10. Cette fois-ci, vous utiliserez la fonction appropriée du package purrr en lieu et place de lapply. Quelles sont les résultats ? Quelle différence voyez-vous entre lapply et les fonctions de purrr ?\n\nlibrary(purrr)\n\n# Supposons que data_medailles_hiver est le deuxième tableau de list_tables\ndata_medailles_hiver &lt;- list_tables[[2]]\n\n# Application de calcul_medailles_individuelles sur la colonne appropriée\ntop_medailles_hiver &lt;- map_int(data_medailles_hiver$Athletes_medailles, calcul_medailles_individuelles)\n\nWarning: Unknown or uninitialised column: `Athletes_medailles`.\n\n# Application de extraire_nationalite_athlete sur la colonne appropriée\nnationalites_hiver &lt;- map(data_medailles_hiver$Athletes_medailles, extraire_nationalite_athlete)\n\nWarning: Unknown or uninitialised column: `Athletes_medailles`.\n\n# Traitement supplémentaire si nécessaire pour obtenir le résultat souhaité\n# Par exemple, vous pouvez utiliser reduce pour combiner les résultats de nationalites_hiver\n\n# Affichage des résultats\nprint(top_medailles_hiver)\n\ninteger(0)\n\nprint(nationalites_hiver)\n\nlist()"
  },
  {
    "objectID": "posts/welcome/index.knit.html",
    "href": "posts/welcome/index.knit.html",
    "title": "Bienvenue sur le blog olympicsWeather !",
    "section": "",
    "text": "Cliquer pour plus d’informations.\nOlympicsWeather est un package conçu pour R, offrant la possibilité de récupérer et afficher les informations météorologiques liées à une adresse spécifique ou à des coordonnées GPS.\nCe package intègre trois fonctions clés : get_forecast, qui récupère les prévisions météo et les présente sous forme de tibble ; visualiser_forecast_d, qui fournit une visualisation des données météorologiques sur une base quotidienne ; et visualiser_forecast_h, qui permet d’afficher les prévisions météo heure par heure.\nÀ vos marques, prêt, codez !\nPour installer le package, vous entrerez la commande suivante :\nremotes::install_github(\"icepop0/olympicsWeather\")\n! Notez que pour lancer cette commande, vous devez avoir lancé le package remotes.\nSi ce n’est pas le cas, exécutez cette commande :\ninstall.packages(\"remotes\")\nlibrary(remotes)\n\n\nQuelles sont les prévisions météo à 7 jours pour le Stade de France ?\n\nlibrary(olympicsWeather)\nvisualiser_forecast_d(\"stade de france\")\n\nPassing 1 address to the Nominatim single address geocoder\n\n\nQuery completed in: 1 seconds\n\n\n\n\n\nTahiti ?\n\nvisualiser_forecast_d(\"Tahiti\")\n\nPassing 1 address to the Nominatim single address geocoder\n\n\nQuery completed in: 1 seconds\n\n\n\n\n\nEt pour les coordonnées GPS 43.276703, 5.334791 ?\n\nvisualiser_forecast_d(43.276703, 5.334791)\n\n\n\n\nquarto create-article “Exercice - Semaine 1”"
  },
  {
    "objectID": "posts/welcome/index.knit.html#librairie-olympicsweather",
    "href": "posts/welcome/index.knit.html#librairie-olympicsweather",
    "title": "Bienvenue sur le blog olympicsWeather !",
    "section": "",
    "text": "Cliquer pour plus d’informations.\nOlympicsWeather est un package conçu pour R, offrant la possibilité de récupérer et afficher les informations météorologiques liées à une adresse spécifique ou à des coordonnées GPS.\nCe package intègre trois fonctions clés : get_forecast, qui récupère les prévisions météo et les présente sous forme de tibble ; visualiser_forecast_d, qui fournit une visualisation des données météorologiques sur une base quotidienne ; et visualiser_forecast_h, qui permet d’afficher les prévisions météo heure par heure.\nÀ vos marques, prêt, codez !\nPour installer le package, vous entrerez la commande suivante :\nremotes::install_github(\"icepop0/olympicsWeather\")\n! Notez que pour lancer cette commande, vous devez avoir lancé le package remotes.\nSi ce n’est pas le cas, exécutez cette commande :\ninstall.packages(\"remotes\")\nlibrary(remotes)\n\n\nQuelles sont les prévisions météo à 7 jours pour le Stade de France ?\n\nlibrary(olympicsWeather)\nvisualiser_forecast_d(\"stade de france\")\n\nPassing 1 address to the Nominatim single address geocoder\n\n\nQuery completed in: 1 seconds\n\n\n\n\n\nTahiti ?\n\nvisualiser_forecast_d(\"Tahiti\")\n\nPassing 1 address to the Nominatim single address geocoder\n\n\nQuery completed in: 1 seconds\n\n\n\n\n\nEt pour les coordonnées GPS 43.276703, 5.334791 ?\n\nvisualiser_forecast_d(43.276703, 5.334791)\n\n\n\n\nquarto create-article “Exercice - Semaine 1”"
  },
  {
    "objectID": "posts/Exercice - Semaine 3/exercice3.html#m1-ecap---202324",
    "href": "posts/Exercice - Semaine 3/exercice3.html#m1-ecap---202324",
    "title": "Exercice3",
    "section": "M1 ECAP - 2023/24",
    "text": "M1 ECAP - 2023/24\n\nlibrary(stringr)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.3\n\nlibrary(lubridate)\n\nWarning: le package 'lubridate' a été compilé avec la version R 4.3.3\n\n\n\nAttachement du package : 'lubridate'\n\n\nLes objets suivants sont masqués depuis 'package:base':\n\n    date, intersect, setdiff, union\n\nlibrary(arrow)\n\nThe tzdb package is not installed. Timezones will not be available to Arrow compute functions.\n\n\n\nAttachement du package : 'arrow'\n\n\nL'objet suivant est masqué depuis 'package:lubridate':\n\n    duration\n\n\nL'objet suivant est masqué depuis 'package:utils':\n\n    timestamp\n\nlibrary(dplyr)\n\nWarning: le package 'dplyr' a été compilé avec la version R 4.3.3\n\n\n\nAttachement du package : 'dplyr'\n\n\nLes objets suivants sont masqués depuis 'package:stats':\n\n    filter, lag\n\n\nLes objets suivants sont masqués depuis 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\n\nWarning: le package 'tidyr' a été compilé avec la version R 4.3.3\n\nlibrary(jsonlite)\n\nWarning: le package 'jsonlite' a été compilé avec la version R 4.3.3\n\nlibrary(RSQLite)\n\nWarning: le package 'RSQLite' a été compilé avec la version R 4.3.3\n\n\n\nImport et lecture des données\n\n1.Listez les fichiers présents dans le dossier data. Quelles sont les extensions des différents fichiers ?\n\nLe fichier data, extension sqlite\nLe fichier olympics_athletes, extension json\nLe fichier tokyo_athletes, extension parquet\n\n\n\n2.Lisez le fichier .parquet en utilisant la librairie arrow. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?\n\n# Remplacez \"chemin/vers/votre/fichier.parquet\" par le chemin de votre fichier\ntokyo_athletes &lt;- read_parquet(\"tokyo_athletes.parquet\")\n\n# Obtenir les dimensions de la table\ndimensions &lt;- dim(tokyo_athletes)\n\n# Lister les noms des colonnes\nnoms_colonnes &lt;- colnames(tokyo_athletes)\n\n# Afficher les résultats\nprint(paste(\"Dimensions de la table : Nombre de lignes =\", dimensions[1], \", Nombre de colonnes =\", dimensions[2]))\n\n[1] \"Dimensions de la table : Nombre de lignes = 11085 , Nombre de colonnes = 3\"\n\nprint(\"Noms des colonnes :\")\n\n[1] \"Noms des colonnes :\"\n\nprint(noms_colonnes)\n\n[1] \"Name\"       \"NOC\"        \"Discipline\"\n\n\nLe fichier tokyo_athletes contient 3 colonnes, et 11 085 lignes.\nLes 3 colonnes sont “Name”, “NOC” et “Discipline.\n\n\n3. Lisez le fichier .json en utilisant la librairie jsonlite. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?\n\nolympics_athletes &lt;- fromJSON(\"olympics_athletes.json\")\n\n# Obtenir les dimensions de la table\ndimensions &lt;- dim(olympics_athletes)\n\n# Lister les noms des colonnes\nnoms_colonnes &lt;- colnames(olympics_athletes)\n\n# Afficher les résultats\nprint(paste(\"Dimensions de la table : Nombre de lignes =\", dimensions[1], \", Nombre de colonnes =\", dimensions[2]))\n\n[1] \"Dimensions de la table : Nombre de lignes = 269731 , Nombre de colonnes = 13\"\n\nprint(\"Noms des colonnes :\")\n\n[1] \"Noms des colonnes :\"\n\nprint(noms_colonnes)\n\n [1] \"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"   \n [9] \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\" \n\n\nLe fichier olympics_athletes contient 13 colonnes, et 269 731 lignes.\nLes 13 colonnes sont :\n\"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"    \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\"\n\n\n4. Importez la librairie RSQLite, et ouvrez une connexion à la base de données sqlite en utilisant la fonction dbConnect. Le driver à utiliser sera SQLite(). Quelles sont les tables présentes dans la table ? Vous pourrez utiliser la fonction dbListTables.\n\ndata &lt;- dbConnect(SQLite(), dbname = \"data.sqlite\")\n\ntables &lt;- dbListTables(data)\n\nprint(\"Tables présentes dans la base de données :\")\n\n[1] \"Tables présentes dans la base de données :\"\n\nprint(tables)\n\n[1] \"tokyo_medals\" \"tokyo_teams\" \n\n\nDeux tables sont présentes : “tokyo_medals” et “tokyo_teams”.\n\n\n5. Créez deux nouvelles tables dans la base de données à l’aide de la fonction dbWriteTable. Les tables s’appeleront respectivement olympics_athletes et tokyo_athletes pour les fichiers olympics_athletes.json et tokyo_athletes.parquet.\n\ndbWriteTable(data, \"olympics_athletes\", olympics_athletes)\ndbWriteTable(data, \"tokyo_athletes\", tokyo_athletes)\n\n#Affichage des résultats\ntables &lt;- dbListTables(data)\n\nprint(\"Tables présentes dans la base de données :\")\n\n[1] \"Tables présentes dans la base de données :\"\n\nprint(tables)\n\n[1] \"olympics_athletes\" \"tokyo_athletes\"    \"tokyo_medals\"     \n[4] \"tokyo_teams\"      \n\n\n\n\n6. Inspectez la table olympics_athletes en utilisant la fonction dbListFields. Quelles sont les colonnes de la table ?\n\ncolonnes &lt;- dbListFields(data, \"olympics_athletes\")\n\nprint(\"Colonnes de la table olympics_athletes :\")\n\n[1] \"Colonnes de la table olympics_athletes :\"\n\nprint(colonnes)\n\n [1] \"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"   \n [9] \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\" \n\n\nLes colonnes sont les suivantes :\n\"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"    \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\" \n\n\n7. Importez cette table depuis la base de données en utilisant la fonction dbReadTable. Convertissez la table en tibble en utilisant la fonction as_tibble.\n\nolympics_athletes &lt;- dbReadTable(data, \"olympics_athletes\")\n\n\nolympics_athletes_tibble &lt;- as_tibble(olympics_athletes)\n\n\n\n\ndplyr, tidyr\n\nDans les questions suivantes, utilisez en priorité les fonctions des packages dplyr, tidyr.\n\n\n\n\n\n8. Convertissez la colonne Sex en variable catégorielle avec la fonction mutate.\n\nolympics_athletes_tibble &lt;- olympics_athletes_tibble %&gt;%\n                            mutate(Sex = as.factor(Sex))\n\n\n\n9. Créez deux colonnes à partir de la colonne Games. La première colonne Year sera une colonne de type integer contenant l’année des jeux. La deuxième colonne isSummer sera une colonne booléenne qui indiquera si les jeux sont des jeux d’été ou d’hiver. Vous pourrez utiliser la fonction separate_wider_delim de tidyr notamment. Les questions suivantes nécessitent l’application de plusieurs instructions en séquence. Essayez tant que possible de chaîner les instructions avec des pipes (%&gt;% ou |&gt;).\n\n\n\n\nolympics_athletes_tibble &lt;- olympics_athletes_tibble %&gt;%\n  # Séparation de la colonne 'Games' en 'Year' et 'Season'\n  separate(Games, into = c(\"Year\", \"Season\"), sep = \" \") %&gt;%\n  # Conversion de 'Year' en entier\n  mutate(Year = as.integer(Year),\n         # Création d'une colonne booléenne pour 'isSummer'\n         isSummer = ifelse(Season == \"Summer\", TRUE, FALSE)) %&gt;%\n  # Suppression de la colonne 'Season' car elle n'est plus nécessaire\n  select(-Season)\n\n\n\n10. Calculez la moyenne d’age des athletes pour chacune des éditions des JO d’été. Quelle édition a compté les athlètes les plus jeunes ? Les plus vieux ?\n\n# Calcul de la moyenne d'âge pour chaque édition des JO d'été\nage_moyen_par_edition &lt;- olympics_athletes_tibble %&gt;%\n  filter(isSummer) %&gt;%\n  group_by(Year) %&gt;%\n  summarize(MoyenneAge = mean(Age, na.rm = TRUE))\n\n# Trouver l'édition avec les athlètes les plus jeunes\nedition_jeunes &lt;- age_moyen_par_edition[which.min(age_moyen_par_edition$MoyenneAge), ]\n\n# Trouver l'édition avec les athlètes les plus vieux\nedition_vieux &lt;- age_moyen_par_edition[which.max(age_moyen_par_edition$MoyenneAge), ]\n\n# Afficher les résultats\nprint(\"Édition avec les athlètes les plus jeunes :\")\n\n[1] \"Édition avec les athlètes les plus jeunes :\"\n\nprint(edition_jeunes)\n\n# A tibble: 1 × 2\n   Year MoyenneAge\n  &lt;int&gt;      &lt;dbl&gt;\n1  1896       23.6\n\nprint(\"Édition avec les athlètes les plus vieux :\")\n\n[1] \"Édition avec les athlètes les plus vieux :\"\n\nprint(edition_vieux)\n\n# A tibble: 1 × 2\n   Year MoyenneAge\n  &lt;int&gt;      &lt;dbl&gt;\n1  1932       30.2\n\n\nL’édition avec les athlètes les plus jeunes est celle de 1896, avec une moyenne d’âge des participants de 23.6 ans.\nL’édition avec les athlètes les plus vieux est celle de 1932, avec une moyenne d’âge des participants de 30.2 ans.\n\n\n11. Quelle est la discipline des JO d’été dont la taille des athlètes féminines est la plus grande ? Quelle a été cette discipline au cours de chacune des éditions ? Calculez le nombre de fois où chaque discipline a été la discipline avec les plus grandes athlètes.\n\n# 1. Discipline avec la taille moyenne des athlètes féminines la plus grande sur tous les JO d'été\ndiscipline_taille_max_femmes &lt;- olympics_athletes_tibble %&gt;%\n  filter(Sex == \"F\", isSummer) %&gt;%\n  group_by(Sport) %&gt;%\n  summarize(TailleMoyenne = mean(Height, na.rm = TRUE)) %&gt;%\n  arrange(desc(TailleMoyenne)) %&gt;%\n  top_n(1, TailleMoyenne)\n\n# 2. Discipline avec les athlètes féminines les plus grandes pour chaque édition des JO d'été\ndiscipline_par_edition &lt;- olympics_athletes_tibble %&gt;%\n  filter(Sex == \"F\", isSummer) %&gt;%\n  group_by(Year, Sport) %&gt;%\n  summarize(TailleMoyenne = mean(Height, na.rm = TRUE), .groups = 'drop') %&gt;%\n  arrange(Year, desc(TailleMoyenne)) %&gt;%\n  group_by(Year) %&gt;%\n  slice(1)\n\n# 3. Compter le nombre de fois où chaque discipline a été en tête\nnombre_fois_en_tete &lt;- discipline_par_edition %&gt;%\n  count(Sport) %&gt;%\n  arrange(desc(n))\n\n# Affichage des résultats\nprint(\"Discipline avec la plus grande taille moyenne des athlètes féminines sur tous les JO d'été :\")\n\n[1] \"Discipline avec la plus grande taille moyenne des athlètes féminines sur tous les JO d'été :\"\n\nprint(discipline_taille_max_femmes)\n\n# A tibble: 1 × 2\n  Sport      TailleMoyenne\n  &lt;chr&gt;              &lt;dbl&gt;\n1 Basketball          182.\n\nprint(\"Discipline avec les athlètes féminines les plus grandes par édition des JO d'été :\")\n\n[1] \"Discipline avec les athlètes féminines les plus grandes par édition des JO d'été :\"\n\nprint(discipline_par_edition)\n\n# A tibble: 28 × 3\n# Groups:   Year [28]\n    Year Sport    TailleMoyenne\n   &lt;int&gt; &lt;chr&gt;            &lt;dbl&gt;\n 1  1900 Croquet           NaN \n 2  1904 Archery           NaN \n 3  1906 Tennis            NaN \n 4  1908 Archery           NaN \n 5  1912 Diving            NaN \n 6  1920 Swimming          166.\n 7  1924 Fencing           168.\n 8  1928 Fencing           172.\n 9  1932 Fencing           173.\n10  1936 Fencing           178 \n# ℹ 18 more rows\n\nprint(\"Nombre de fois où chaque discipline a été en tête pour la taille des athlètes féminines :\")\n\n[1] \"Nombre de fois où chaque discipline a été en tête pour la taille des athlètes féminines :\"\n\nprint(nombre_fois_en_tete)\n\n# A tibble: 28 × 3\n# Groups:   Year [28]\n    Year Sport        n\n   &lt;int&gt; &lt;chr&gt;    &lt;int&gt;\n 1  1900 Croquet      1\n 2  1904 Archery      1\n 3  1906 Tennis       1\n 4  1908 Archery      1\n 5  1912 Diving       1\n 6  1920 Swimming     1\n 7  1924 Fencing      1\n 8  1928 Fencing      1\n 9  1932 Fencing      1\n10  1936 Fencing      1\n# ℹ 18 more rows\n\n\n\n\n\nFonctions stringr, lubridate :\n\nVous disposez du texte suivant :\n\n\nLes jeux olympiques d’été se déroulent normalement tous les 4 ans, durant les mois de Juillet et Août. Les jeux de Rio ont eu lieu du 5 Août 2016 au 20 Août 2016, ceux de Tokyo du 23 Juillet 2021 au 8 Août 2021, et ceux de Paris auront lieu du 26 Juillet 2024 au 11 Août 2024. Plus de 10000 athlètes sont attendus du monde entier à Paris.\n\n\n\n\n\n\n\n\n12. En utilisant les fonctions du packages stringr, extrayez les dates des différentes éditions des JO. Aide : définissez une expression régulière capable de capturer une séquence de caractères représentant une date telle que “26 Juillet 2024”. Vous pourrez utiliser cette regex avec la fonction str_extract_all par exemple.\n\ntexte &lt;- \"Les jeux olympiques d’été se déroulent normalement tous les 4 ans, durant les mois de Juillet et Août. Les jeux de Rio ont eu lieu du 5 Août 2016 au 20 Août 2016, ceux de Tokyo du 23 Juillet 2021 au 8 Août 2021, et ceux de Paris auront lieu du 26 Juillet 2024 au 11 Août 2024. Plus de 10000 athlètes sont attendus du monde entier à Paris.\"\n\n# Expressions régulières pour chaque ville\nregex_rio &lt;- \"Rio.*?\\\\d{1,2} [A-Za-z]+ \\\\d{4}\"\nregex_tokyo &lt;- \"Tokyo.*?\\\\d{1,2} [A-Za-z]+ \\\\d{4}\"\nregex_paris &lt;- \"Paris.*?\\\\d{1,2} [A-Za-z]+ \\\\d{4}\"\n\n# Extraction des dates\ndates_rio &lt;- str_extract_all(texte, regex_rio, simplify = TRUE)\ndates_tokyo &lt;- str_extract_all(texte, regex_tokyo, simplify = TRUE)\ndates_paris &lt;- str_extract_all(texte, regex_paris, simplify = TRUE)\n\n# Affichage des résultats\nprint(\"Dates des jeux de Rio :\")\n\n[1] \"Dates des jeux de Rio :\"\n\nprint(dates_rio)\n\n     [,1]                                                                              \n[1,] \"Rio ont eu lieu du 5 Août 2016 au 20 Août 2016, ceux de Tokyo du 23 Juillet 2021\"\n\nprint(\"Dates des jeux de Tokyo :\")\n\n[1] \"Dates des jeux de Tokyo :\"\n\nprint(dates_tokyo)\n\n     [,1]                      \n[1,] \"Tokyo du 23 Juillet 2021\"\n\nprint(\"Dates des jeux de Paris :\")\n\n[1] \"Dates des jeux de Paris :\"\n\nprint(dates_paris)\n\n     [,1]                                  \n[1,] \"Paris auront lieu du 26 Juillet 2024\"\n\n\n\n\n13. Remplacez les noms des mois par leur numéro pour rendre ces éléments convertibles en date en utilisant la fonction str_replace.\n\n# Remplacement des noms des mois par leurs numéros\nmois_replacement &lt;- c(\"Janvier\" = \"01\", \"Février\" = \"02\", \"Mars\" = \"03\", \"Avril\" = \"04\", \n                      \"Mai\" = \"05\", \"Juin\" = \"06\", \"Juillet\" = \"07\", \"Août\" = \"08\",\n                      \"Septembre\" = \"09\", \"Octobre\" = \"10\", \"Novembre\" = \"11\", \"Décembre\" = \"12\")\n\n# Extraction des dates pour Rio, Tokyo et Paris (réutilisation du code de la question précédente)\n# ...\n\n# Remplacement des noms des mois dans les dates extraites\ndates_rio &lt;- str_replace_all(dates_rio, mois_replacement)\ndates_tokyo &lt;- str_replace_all(dates_tokyo, mois_replacement)\ndates_paris &lt;- str_replace_all(dates_paris, mois_replacement)\n\n# Affichage des résultats\nprint(\"Dates des jeux de Rio avec mois numérotés :\")\n\n[1] \"Dates des jeux de Rio avec mois numérotés :\"\n\nprint(dates_rio)\n\n[1] \"Rio ont eu lieu du 5 08 2016 au 20 08 2016, ceux de Tokyo du 23 07 2021\"\n\nprint(\"Dates des jeux de Tokyo avec mois numérotés :\")\n\n[1] \"Dates des jeux de Tokyo avec mois numérotés :\"\n\nprint(dates_tokyo)\n\n[1] \"Tokyo du 23 07 2021\"\n\nprint(\"Dates des jeux de Paris avec mois numérotés :\")\n\n[1] \"Dates des jeux de Paris avec mois numérotés :\"\n\nprint(dates_paris)\n\n[1] \"Paris auront lieu du 26 07 2024\"\n\n\n\n\n14. Convertissez ces 3 éléments en date en utilisant la fonction appropriée du package lubridate.\n\n# Conversion en dates\nconvert_to_date &lt;- function(dates) {\n  dates &lt;- unlist(dates)\n  lapply(dates, function(date) dmy(date))\n}\n\ndates_rio &lt;- convert_to_date(dates_rio)\n\nWarning: All formats failed to parse. No formats found.\n\ndates_tokyo &lt;- convert_to_date(dates_tokyo)\ndates_paris &lt;- convert_to_date(dates_paris)\n\n# Affichage des résultats\nprint(\"Dates des jeux de Rio converties en dates :\")\n\n[1] \"Dates des jeux de Rio converties en dates :\"\n\nprint(dates_rio)\n\n[[1]]\n[1] NA\n\nprint(\"Dates des jeux de Tokyo converties en dates :\")\n\n[1] \"Dates des jeux de Tokyo converties en dates :\"\n\nprint(dates_tokyo)\n\n[[1]]\n[1] \"2021-07-23\"\n\nprint(\"Dates des jeux de Paris converties en dates :\")\n\n[1] \"Dates des jeux de Paris converties en dates :\"\n\nprint(dates_paris)\n\n[[1]]\n[1] \"2024-07-26\"\n\n\n\n\n15. Combien de jours ont séparés les éditions de Rio et Tokyo ? Et sépareront les éditions de Tokyo et de Paris ? Faites le même calcul en semaines.\n\nfin_rio &lt;- max(unlist(dates_rio))\ndebut_tokyo &lt;- min(unlist(dates_tokyo))\nfin_tokyo &lt;- max(unlist(dates_tokyo))\ndebut_paris &lt;- min(unlist(dates_paris))\n\n# Calcul des intervalles en jours\njours_entre_rio_tokyo &lt;- as.integer(debut_tokyo - fin_rio)\njours_entre_tokyo_paris &lt;- as.integer(debut_paris - fin_tokyo)\n\n# Conversion des jours en semaines\nsemaines_entre_rio_tokyo &lt;- jours_entre_rio_tokyo / 7\nsemaines_entre_tokyo_paris &lt;- jours_entre_tokyo_paris / 7\n\n# Affichage des résultats\nprint(paste(\"Nombre de jours entre Rio et Tokyo:\", jours_entre_rio_tokyo))\n\n[1] \"Nombre de jours entre Rio et Tokyo: NA\"\n\nprint(paste(\"Nombre de semaines entre Rio et Tokyo:\", semaines_entre_rio_tokyo))\n\n[1] \"Nombre de semaines entre Rio et Tokyo: NA\"\n\nprint(paste(\"Nombre de jours entre Tokyo et Paris:\", jours_entre_tokyo_paris))\n\n[1] \"Nombre de jours entre Tokyo et Paris: 1099\"\n\nprint(paste(\"Nombre de semaines entre Tokyo et Paris:\", semaines_entre_tokyo_paris))\n\n[1] \"Nombre de semaines entre Tokyo et Paris: 157\""
  }
]